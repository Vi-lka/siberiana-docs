import { Callout } from 'nextra/components'

# Поля

Здесь вы можете ознакомиться со всеми видами полей для каждой сущности.

## Общие

Имеются практически у каждой сущности.

    - `category` - Категория
    - `collections` - Коллекции
    - `status` - Состояние (*listed* - опубликованно, *unlisted* или *draft* - недостпуно, не оторажается на сайте)
    - `id` - Уникальный идентификатор
    - `displayName` - Название
    - `abbreviation` - Аббревиатура
    - `description` - Описание
    - `primaryImageURL` - Ссылка на **Основное Фото**
    - `additionalImagesUrls` - Ссылки на **Дополнительные Фото**
    - `country` - Страна
    - `region` - Регион
    - `district` - Район
    - `settlement` - Населенный пункт
    - `location` - Локация
    - `license` - Лицензия
    - `externalLink` - Внешняя ссылка
    - `totalCount` - Количество объектов (с учетом фильтрации)
    - `pageInfo` и `сursor` - Информация для пагинации (Подробнее см. [Пагинация](/arguments/pagination))
    - `orderBy` - Позволяет указать сортировку по определенному полю `field` и направлению `direction`  
    (`ASC` - возрастание; `DESC` - убывание)

## Уникальные

    ### Категории - `categories`
        - `slug` - Это **уникальная строка идентификатор**, понятная человеку (в отличие от ID)

    ### Коллекции - `collections`
        - `slug` - Это **уникальная строка идентификатор**, понятная человеку (в отличие от ID)
        - `type` - Определяет какой **тип основных объектов** привязан к коллекции
        - `art` -  Объекты Изобразительного искусства
        - `artifacts` - Артефакты
        - `dendrochronology` - Объекты Дендрохронологии
        - `petroglyphs` - Петроглифы
        - `books` - Книги
        - `herbaria` - Гербарии
        - `protectedAreaPictures` - Фотографии ООПТ
        - `authors` - Авторы Коллекции (Личности)

    ### Артефакты - `artifacts`
        - `kpNumber` - Номер КП
        - `goskatalogNumber` - Госкаталог номер
        - `inventoryNumber` - Инвентарный номер
        - `dating` - Датировка (строковое значение, понятное человеку)
        - `datingStart` и `datingEnd` - Датировка (числовые значения, см. [Датировка](#датировка---dating-datingstart-datingend))
        - `width` - Ширина
        - `height` - Высота
        - `length` - Длина
        - `depth` - Глубина
        - `diameter` - Диаметр
        - `dimensions` - Размеры (строковое значение, понятное человеку, см. [Размеры](#размеры---dimensions))
        - `weight` - Вес
        - `culturalAffiliation` - Культура
        - `ethnos` - Этнос
        - `admissionDate` - Дата приема в фонд
        - `typology` - Типология
        - `chemicalComposition` - Химический состав
        - `mediums` - Материалы
        - `techniques` - Техники
        - `set` - Комплекс Памятников
        - `monument` - Памятник
        - `model` - 3D-модель
        - `authors` - Авторы публикаций или исследований (Личности)
        - `donor` - Донор (Личность, предоставляющая объект, ответственный)
        - `projects` - Проекты
        - `publications` - Публикации
        - `organization` - Организация (Предоставляющая объект)

    ### Петроглифы - `petroglyphs`
        - `number` - Номер кургана по учетной документации (УД)
        - `mound` - Курган
        - `accountingDocumentationDate`- Дата составления учетной документации (УД)
        - `accountingDocumentationAddress` - Адрес по учетной документации (УД)
        - `accountingDocumentationAuthor` - Составитель учетной документации (УД)
        - `accountingDocumentationInformation` - Параметры кургана по учетной документации (УД)
        - `position` - Место камня в ограде
        - `geometricShape` - Геометрическая форма камня
        - `culturalAffiliation` - Культура
        - `techniques` - Техники
        - `dating` - Датировка (строковое значение, понятное человеку)
        - `datingStart` и `datingEnd` - Датировка (числовые значения, см. [Датировка](#датировка---dating-datingstart-datingend))
        - `width` - Ширина
        - `height` - Высота
        - `length` - Длина
        - `depth` - Глубина
        - `diameter` - Диаметр
        - `dimensions` - Размеры (строковое значение, понятное человеку, см. [Размеры](#размеры---dimensions))
        - `weight` - Вес
        - `orientation` - Ориентация грани с рисунками на камне
        - `planePreservation` - Cохранность плоскости
        - `photoCode` - Шифр фотографии
        - `geometry` - Географические координаты
        - `model` - 3D-модель
        - `publications` - Публикации

    ### Изобразительно искусство - `arts`
        - `number` - Номер
        - `author` - Автор
        - `artGenre` - Жанр
        - `artStyle` - Стиль
        - `techniques` - Техники
        - `dating` - Датировка (строковое значение, понятное человеку)
        - `datingStart` и `datingEnd` - Датировка (числовые значения, см. [Датировка](#датировка---dating-datingstart-datingend))
        - `width` - Ширина
        - `height` - Высота
        - `length` - Длина
        - `depth` - Глубина
        - `diameter` - Диаметр
        - `dimensions` - Размеры (строковое значение, понятное человеку, см. [Размеры](#размеры---dimensions))

    ### Книги - `books`
        - `files` - Ссылки на **Файлы**
        - `year` - Год издания
        - `authors` - Авторы
        - `bookGenres` - Разделы/Жанры
        - `periodical` - Издание/Журнал
        - `publisher` - Издатель
        - `library` - Библиотека (Организация)

    ### Дендрохронология - `dendrochronologies`
        - `dating` - Датировка (строковое значение, понятное человеку)
        - `datingStart` и `datingEnd` - Датировка (числовые значения, см. [Датировка](#датировка---dating-datingstart-datingend))
        - `dataURL` - Ссылка на Данные
        - `chartURL` - Ссылка на графики
        - `analysis` - Анализы Дендрохронологии
        - `analysisData` - Данные Анализов
        - `analysisURL` - Ссылка на Анализы

    ### Гербарий - `herbaria`
        - `date` - Дата сбора
        - `author` - Коллектор
        - `group` - Отдел
        - `familia` - Семейство
        - `genus` - Род
        - `species` - Вид
        - `location` - Место сбора

    ### Фотографии ООПТ - `protectedAreaPictures`
        - `shootingDate` - Дата съемки
        - `author` - Автор фотографии
        - `protectedArea` - ООПТ (Особо охраняемая природная территория)
        - `geometry` - Географические координаты

## Спец. поля

Некоторые поля имеют специфичное поведение. Здесь мы опишем принцип их работы.

    ### Датировка - `dating`, `datingStart`, `datingEnd`

        Поле `dating` строиться автоматически на стороне front-end в админ-панели, исходя из данных в `datingStart` и `datingEnd` (пример ниже).
        Администраторы также могут вписать любую информацию в него или редактировать сгенерированную автоматически.

        Пример `dating`: *"VI век - IX век", "20 т.л.н.", "Неолит - Бронзовый век"*

        `datingStart` и `datingEnd` это числовые значения выражающие года в количестве. 
        Для указания одной даты используется только `datingStart`, `datingEnd` остается пустым. 
        Например: 
        - **500** - **VI век**; 
        - **-700** - **VII век до н.э.** и т.д.

        Для указания промежутков указывается начало `datingStart` и конец `datingEnd`:
        - **-2850 - 450** - **Начало III тыс. до н.э. - Середина I тыс. **; 
        - **-2500000 - -3901** - **Палеолит - Неолит**

        <Callout type="warning" emoji="⚠️">
            Администраторы могут вносить любое значение в поле `dating` по усмотрению специалистов. 
            Поэтому текст может не совпадать по формулам со значениями `datingStart` и `datingEnd`.
        </Callout>

        Функции по которым строиться поле `dating`:

        ```typescript showLineNumbers filename="getDating.ts"
        export type Prefix = {
          label: string;
          start: string;
          startBC: string | undefined;
          end: string;
        };

        export type DatingType = "year" | "century" | "millennium";

        export type Era = {
          start: number;
          end: number;
          label: string;
        };

        export const ERA = [
          { start: -2500000, end: -9001, label: "Палеолит" },
          { start: -100000, end: -40001, label: "Средний палеолит" },
          { start: -40000, end: -9001, label: "Верхний палеолит" },
          { start: -2500000, end: -100001, label: "Нижний палеолит" },
          { start: -9000, end: -7001, label: "Мезолит" },
          { start: -7000, end: -3901, label: "Неолит" },
          { start: -7000, end: -5501, label: "Ранний неолит" },
          { start: -5500, end: -3901, label: "Поздний неолит" },
          { start: -3900, end: -3501, label: "Энеолит" },
          { start: -3500, end: -1000, label: "Бронзовый век" },
          { start: -3500, end: -2101, label: "Ранний бронзовый век" },
          { start: -2100, end: -1601, label: "Средний бронзовый век" },
          { start: -1600, end: -1201, label: "Развитый бронзовый век" },
          { start: -1200, end: -1001, label: "Финальный бронзовый век" },
          { start: -1000, end: -801, label: "Переход от бронзового к раннему железному веку" },
          { start: -800, end: -501, label: "Ранний железный век" },
          { start: -800, end: -201, label: "Скифское время" },
          { start: -150, end: 150, label: "Хуннское время" },
          { start: 250, end: 550, label: "Сяньбийско-жужанское время" },
          { start: 550, end: 800, label: "Тюркское время" },
          { start: 550, end: 1601, label: "Средневековье" },
          { start: 550, end: 1000, label: "Раннее средневековье" },
          { start: 1001, end: 1401, label: "Развитое средневековье" },
          { start: 1401, end: 1601, label: "Позднее средневековье" },
          { start: 1201, end: 1550, label: "Монгольское время" },
          { start: 1601, end: 1800, label: "Раннее Новое время" },
          { start: 1601, end: 1900, label: "Новое время" },
        ] as Era[];

        export const PREFIXES = [
          { label: "Начало", start: "01", startBC: "85", end: "15" },
          { label: "Конец", start: "85", startBC: "01", end: "00" },
          { label: "Середина", start: "45", startBC: "55", end: "55" },
          { label: "Первая половина", start: "01", end: "50" },
          { label: "Вторая половина", start: "51", end: "00" },
          { label: "Первая треть", start: "01", end: "33" },
          { label: "Вторая треть", start: "34", end: "66" },
          { label: "Третья треть", start: "67", end: "00" },
          { label: "Первая четверть", start: "01", end: "25" },
          { label: "Вторая четверть", start: "26", end: "50" },
          { label: "Третья четверть", start: "51", end: "75" },
          { label: "Четвертая четверть", start: "76", end: "00" },
        ] as Prefix[];

        export function centurize(year: number) {
          return Math.ceil(Math.abs(year / 100));
        }

        export const romanize = (original: number): string => {
          if (original === 0) return "0";
          if (original < 0 || original > 3999)
            return "Error: Input integer limited to 1 through 3999";
        
          const numerals = [
            ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"], // 1-9
            ["X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"], // 10-90
            ["C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"], // 100-900
            ["M", "MM", "MMM"], // 1000-3000
          ];

          const digits = Math.round(original).toString().split("");
          let position = digits.length - 1;

          return digits.reduce((roman, digit) => {
            if (digit !== "0") {
              roman += numerals[position][parseInt(digit) - 1];
            }

            position -= 1;

            return roman;
          }, "");
        };

        export function getEra(start: number, end: number): string | false {
          const result = ERA.find((item) => item.start === start && item.end === end);
          if (!!result) {
            return result.label;
          } else {
            const firstResult = ERA.find((item) => item.start === start);
            const secondResult = ERA.find((item) => item.end === end);

            if (firstResult && secondResult)
              return `${firstResult.label} - ${secondResult.label}`;
            else return false;
          }
        }

        export function getPrefix(start: number, end: number) {
          const startAbs = start < 0 && end < 0 ? Math.abs(end) : Math.abs(start);
          const endAbs = start < 0 && end < 0 ? Math.abs(start) : Math.abs(end);

          if (startAbs < endAbs) {
            if ((startAbs - 1) % 100 === 0 && end < 999999) {
              switch (endAbs - startAbs) {
                case 14:
                  return { prefix: "Начало", century: true };
                case 49:
                  return { prefix: "Первая половина", century: true };
                case 32:
                  return { prefix: "Первая треть", century: true };
                case 24:
                  return { prefix: "Первая четверть", century: true };
              }
            } else if (endAbs % 100 === 0 && startAbs < 999999) {
              switch (endAbs - startAbs) {
                case 15:
                  return { prefix: "Конец", century: true };
                case 49:
                  return { prefix: "Вторая половина", century: true };
                case 33:
                  return { prefix: "Третья треть", century: true };
                case 24:
                  return { prefix: "Четвертая четверть", century: true };
              }
            } else if (startAbs % 100 === 34 && endAbs - startAbs === 32) {
              return { prefix: "Вторая треть", century: true };
            } else if (startAbs % 100 === 26 && endAbs - startAbs === 24) {
              return { prefix: "Вторая четверть", century: true };
            } else if (startAbs % 100 === 51 && endAbs - startAbs === 24) {
              return { prefix: "Третья четверть", century: true };
            } else if (startAbs % 100 === 45 && endAbs - startAbs === 10) {
              return { prefix: "Середина", century: true };
            } else if (endAbs === 999999) {
              return { prefix: "не ранее", century: false };
            }
          } else if (startAbs === 999999) {
            return { prefix: "не позднее", century: false };
          } else if (startAbs !== 0 && start === end) {
            return { prefix: "около", century: false };
          }
          return null;
        }

        export function getMultiPrefixData(
          start: number,
          end: number,
          type: DatingType,
        ) {
          const startAbs = Math.abs(start);
          const endAbs = Math.abs(end);

          const isMillennium = type === "millennium";

          let startEnding = startAbs.toString().slice(-2);
          if (startEnding.length < 2) startEnding = "0" + startEnding;
          let endEnding = endAbs.toString().slice(-2);
          if (endEnding.length < 2) endEnding = "0" + endEnding;

          const startPrefix = PREFIXES.find((item) =>
            start < 0 ? item.startBC === startEnding : item.start === startEnding,
          );
          const endPrefix = PREFIXES.find((item) =>
            end < 0 ? item.startBC === endEnding : item.start === endEnding,
          );

          const startCentury = romanize(centurize(Math.abs(start)));
          const endCentury = romanize(centurize(Math.abs(end)));

          const startString = startPrefix
            ? isMillennium
              ? `${startPrefix.label} ${startCentury} тыс. ${
                  start >= 0 ? "" : "до н.э."
                }`
              : `${startPrefix.label} ${startCentury} века ${
                  start >= 0 ? "" : "до н.э."
                }`
            : isMillennium
              ? `${startCentury} тыс. ${start >= 0 ? "" : "до н.э."}`
              : `${startCentury} век ${start >= 0 ? "" : "до н.э."}`;

          const endString = endPrefix
            ? isMillennium
              ? `${endPrefix.label} ${endCentury} тыс. ${end >= 0 ? "" : "до н.э."}`
              : `${endPrefix.label} ${endCentury} века ${end >= 0 ? "" : "до н.э."}`
            : isMillennium
              ? `${endCentury} тыс. ${end >= 0 ? "" : "до н.э."}`
              : `${endCentury} век ${end >= 0 ? "" : "до н.э."}`;

          return `${startString} - ${endString}`;
        }

        export function getMillennium(start: number, end: number) {
          const usableStart = start / 10;
          const usableEnd = end / 10;
          const difference = Math.abs(Math.abs(start) - Math.abs(end));

          const prefix = getPrefix(usableStart, usableEnd);

          if (!!prefix && prefix.century) {
            const millennium = romanize(centurize(Math.abs(usableStart)));
            return start > 0
              ? `${prefix.prefix} ${millennium} тыс.`
              : `${prefix.prefix} ${millennium} тыс. до н.э.`;
          } else if (difference === 990) {
            if (start > 0) return `${romanize(centurize(Math.abs(usableStart)))} тыс.`;
            else return `${romanize(centurize(Math.abs(usableEnd)))} тыс. до н.э.`;
          } else return getMultiPrefixData(usableStart, usableEnd, "millennium");
        }

        export function getDating(
          start: number,
          end: number,
          type: DatingType,
        ): string {
          const prefix = getPrefix(start, end);
          const difference = Math.abs(Math.abs(start) - Math.abs(end));

          if (start === 0 && end === 0) return "";

          if (!!prefix) {
            if (prefix.century) {
              const century = romanize(centurize(Math.abs(start)));
              return start > 0
                ? `${prefix.prefix} ${century} века`
                : `${prefix.prefix} ${century} века до н.э.`;
            } else {
              const year = start === -999999 ? end : start;
              return `${prefix.prefix} ${year} года`;
            }
          } else if (difference === 99) {
            if (start > 0) return `${romanize(centurize(Math.abs(start)))} век`;
            else return `${romanize(centurize(Math.abs(end)))} век до н.э.`;
          } else {
            const era = getEra(start, end);

            if (era) {
              return era;
            } else {
              if (start % 10 === 0 && end - start === 9) return `${start}-е годы`;
              if (
                start % 10 === 0 &&
                end - start > 9 &&
                (end - start) % 10 === 9 &&
                end - start < 190
              )
                return `${start}-${end - 9}-е годы`;
              else {
                if (end !== 0) {
                  if (type === "century") {
                    return getMultiPrefixData(start, end, "century");
                  } else if (type === "millennium") {
                    return getMillennium(start, end);
                  } else return `${start}-${end} гг.`;
                } else return `${start} г.`;
              }
            }
          }
        }

        export function generateValues(value: string, prefix: Prefix | undefined) {
          const valueNum = Number(value);
          const valueNumAbs = Math.abs(valueNum);

          const prefixStartNum = Number(prefix?.start);
          const prefixEndNum = Number(prefix?.end);

          const isDoubleDigitCentury = valueNumAbs < 11;
          const isInMiddle = prefixStartNum >= 51 && prefixEndNum < 75;

          const forStart = isDoubleDigitCentury
            ? "0" + Math.abs(valueNumAbs - 1).toString()
            : (valueNumAbs - 1).toString();

          const forEnd = isDoubleDigitCentury
            ? isInMiddle
              ? "0" + valueNumAbs.toString()
              : "0" + Math.abs(valueNumAbs - 1).toString()
            : isInMiddle
              ? value
              : (valueNumAbs - 1).toString();

          return { forStart, forEnd };
        }
        ```

    ### Размеры - `dimensions`

        Поле `dimensions` строиться автоматически на стороне front-end в админ-панели, исходя из данных в
        `width`, `height`, `length`, `depth`, `diameter`:

        ```typescript showLineNumbers filename="sizes-utils.ts"
        export type Sizes = {
          length: number;
          width: number;
          height: number;
          depth: number;
          diameter: number;
        };

        export function isWhat(sizes: Sizes): "diameter" | "3D" | "2D" | "none" {
          if (sizes.diameter > 0) return "diameter";
          if (sizes.depth > 0) return "3D";
          if (sizes.length > 0) return "2D";
          else return "none";
        }
        
        export function isZero(sizes: Sizes) {
          if (
            sizes.width === 0 &&
            sizes.height === 0 &&
            sizes.length === 0 &&
            sizes.depth === 0 &&
            sizes.diameter === 0
          )
            return true;
          else return false;
        }
        
        export function getLable(sizes: Sizes) {
          if (isZero(sizes)) return "__";
          if (sizes.diameter > 0)
            return `Высота: ${sizes.height} см;\nДиаметр: ${sizes.diameter} см;`;
          if (sizes.depth > 0)
            return `${sizes.width}x${sizes.height}x${sizes.depth} см`;
          if (sizes.length > 0) return `${sizes.width}x${sizes.length} см`;
          else return "";
        }
        ```






